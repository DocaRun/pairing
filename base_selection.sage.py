

# This file was *autogenerated* from the file base_selection.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_500 = Integer(500); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_180 = Integer(180); _sage_const_126 = Integer(126); _sage_const_55 = Integer(55); _sage_const_1006 = Integer(1006); _sage_const_11 = Integer(11); _sage_const_48 = Integer(48)
import math
import copy

MAX = pow(_sage_const_2 ,_sage_const_500 )

def coprime_check(T,cand):
    n = len(T)
    flag = True
    for i in range(n):
        if math.gcd(T[i],cand)!=_sage_const_1 :
            flag = False
    return flag

def prime_factorize(n):
    if is_prime(n):
        return MAX
    fact = factor(n)
    if len(fact)>_sage_const_2 :
        if len(fact[_sage_const_0 ])>_sage_const_2 :
            return fact[_sage_const_0 ][_sage_const_0 ]
        else:
            return fact[_sage_const_1 ][_sage_const_0 ]
    else:
        return MAX

def eqar(A,B):
    n = _sage_const_0 
    if len(A)<=len(B):
        n = len(A)
    else:
        n= len(B)
    flag = True
    for i in range(n):
        if A[i]!=B[i]:
            flag = False
    return flag

def FCFSpp(w,n):
    blacklist = [_sage_const_0 ]
    previous_blacklist = [_sage_const_0 ]
    TT = []
    _round = _sage_const_1 
    p2w = pow(_sage_const_2 ,w)
    while True:
        _round+=_sage_const_1 
        previous_blacklist = copy.copy(blacklist)
        i = _sage_const_1 
        T = []
        while len(T)<_sage_const_2 *n:
            cand = pow(_sage_const_2 ,w)-i
            if coprime_check(T,cand) and (cand not in blacklist):
                T.append(cand)
            i+=_sage_const_2 
        assert len(T)==_sage_const_2 *n
        for j in range(_sage_const_0 ,_sage_const_2 *n):
            f2 = prime_factorize(T[j])
            if f2 < (T[j]-T[_sage_const_2 *n-_sage_const_1 ])//_sage_const_2 :
                blacklist.append(T[j])
        TT = copy.copy(T)
        if len(previous_blacklist)==len(blacklist):
            break
            
    di = []
    for t in TT:
        di.append(p2w-t)
    di.sort()
    
    diB = []
    diC = []
    i=_sage_const_0 
    while i<_sage_const_2 *n:
        diB.append(di[i])
        diC.append(di[i+_sage_const_1 ])
        i+=_sage_const_2 
    assert len(diB)==n and len(diC)==n
        
    return diB,diC

def area(w,n):
    #area_ = (25*math.ceil(w/5)*n+(w+18)*(n-1)+w*(n-1)+10*w)*n
    area_ = pow(n,_sage_const_2 )*(_sage_const_180 *w+_sage_const_126 )+_sage_const_55 *n*w
    return area_

    #return (n+10)*w+(2*w+19)*(n-1) 

if __name__ == '__main__':
    #p = 581
    #n = 10
    #w = math.ceil(p/n)
    #print('n',n)
    #print('w',w)
    #diB,diC = FCFSpp(w=w,n=n)
    #print(diB)
    #print(diC)

    p = _sage_const_1006 
    n = _sage_const_11 
    #w = math.ceil(p/n)
    w = _sage_const_48 
    print('n',n)
    print('w',w)
    diB,diC = FCFSpp(w,n)
    print(diB)
    print(diC)

